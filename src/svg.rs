use std::fs::File;
use std::io::{self, Write};
use std::path::PathBuf;

pub type ShapeId = usize;

pub struct SVG {
	shapes: Vec<Shape>,
}

#[derive(Debug, Clone)]
struct RectData {
	x: i32,
	y: i32,
	w: i32,
	h: i32,
	colour: (u8, u8, u8, f32),
	label: Option<String>,
	hover: Option<String>,
}

#[derive(Debug, Clone)]
struct WireData {
	shape_a: ShapeId,
	shape_b: ShapeId,
	attachment_a: u32,
	attachment_b: u32,
}

#[derive(Debug, Clone)]
enum Shape {
	Rect(RectData),
	Wire(WireData),
	// New variants for arbitrary lines and text
	Line {
		x1: i32,
		y1: i32,
		x2: i32,
		y2: i32,
		colour: String,
		stroke_width: i32,
	},
	Text {
		x: i32,
		y: i32,
		text: String,
		colour: String,
		font_size: i32,
		anchor: Option<String>,
		// (angle, cx, cy) for rotation; if None, no transform is applied.
		rotate: Option<(f32, i32, i32)>,
	},
	Circle {
		cx: i32,
		cy: i32,
		r: i32,
		colour: (u8, u8, u8),
		label: Option<String>,
		hover: Option<String>,
	},
}

#[derive(Debug, Clone, Copy)]
pub struct GridSpec {
	cell_width: i32,
	cell_height: i32,
	margin: i32,
}

impl SVG {
	pub fn new() -> Self {
		SVG { shapes: Vec::new() }
	}

	pub fn new_grid(cell_width: i32, cell_height: i32, margin: i32) -> GridSpec {
		GridSpec {
			cell_width,
			cell_height,
			margin,
		}
	}

	pub fn add_fill_cell(
		&mut self,
		grid: GridSpec,
		x: i32,
		y: i32,
		colour: (u8, u8, u8),
		label: Option<String>,
		hover: Option<String>,
	) -> ShapeId {
		let x = x * (grid.cell_width + grid.margin);
		let y = y * (grid.cell_height + grid.margin);
		self.add_rect(
			x,
			y,
			grid.cell_width,
			grid.cell_height,
			colour,
			label,
			hover,
		)
	}

	pub fn add_line_cell(
		&mut self,
		grid: GridSpec,
		x1: i32,
		y1: i32,
		x2: i32,
		y2: i32,
		colour: Option<String>,
		width: Option<i32>,
	) {
		let x1 = x1 * (grid.cell_width + grid.margin) + grid.cell_width / 2;
		let y1 = y1 * (grid.cell_height + grid.margin) + grid.cell_height / 2;
		let x2 = x2 * (grid.cell_width + grid.margin) + grid.cell_width / 2;
		let y2 = y2 * (grid.cell_height + grid.margin) + grid.cell_height / 2;
		self.add_line(x1, y1, x2, y2, colour, width)
	}

	pub fn add_rect(
		&mut self,
		x: i32,
		y: i32,
		w: i32,
		h: i32,
		colour: (u8, u8, u8),
		label: Option<String>,
		hover: Option<String>,
	) -> ShapeId {
		let rect = RectData {
			x,
			y,
			w,
			h,
			colour: (colour.0, colour.1, colour.2, 1.0),
			label: label.map(|s| s.to_string()),
			hover: hover.map(|s| s.to_string()),
		};
		self.shapes.push(Shape::Rect(rect));
		self.shapes.len() - 1
	}

	pub fn add_rect_ext(
		&mut self,
		x: i32,
		y: i32,
		w: i32,
		h: i32,
		colour: (u8, u8, u8, f32),
		label: Option<String>,
		hover: Option<String>,
	) -> ShapeId {
		let rect = RectData {
			x,
			y,
			w,
			h,
			colour: colour,
			label: label.map(|s| s.to_string()),
			hover: hover.map(|s| s.to_string()),
		};
		self.shapes.push(Shape::Rect(rect));
		self.shapes.len() - 1
	}

	pub fn add_line(
		&mut self,
		x1: i32,
		y1: i32,
		x2: i32,
		y2: i32,
		colour: Option<String>,
		width: Option<i32>,
	) {
		let colour = colour.unwrap_or_else(|| "black".to_owned());
		let stroke_width = width.unwrap_or(1).min(1);
		self.shapes.push(Shape::Line {
			x1,
			y1,
			x2,
			y2,
			colour,
			stroke_width,
		});
	}

	pub fn add_wire(
		&mut self,
		a: ShapeId,
		b: ShapeId,
		attachment_a: u32,
		attachment_b: u32,
	) -> ShapeId {
		assert!(attachment_a <= 3, "attachment_a must be 0..3");
		assert!(attachment_b <= 3, "attachment_b must be 0..3");
		assert!(a < self.shapes.len(), "Invalid shape index for 'a'");
		assert!(b < self.shapes.len(), "Invalid shape index for 'b'");

		let line = WireData {
			shape_a: a,
			shape_b: b,
			attachment_a,
			attachment_b,
		};
		self.shapes.push(Shape::Wire(line));
		self.shapes.len() - 1
	}

	pub fn add_circle(
		&mut self,
		cx: i32,
		cy: i32,
		r: i32,
		colour: (u8, u8, u8),
		label: Option<String>,
		hover: Option<String>,
	) -> ShapeId {
		self.shapes.push(Shape::Circle {
			cx,
			cy,
			r,
			colour,
			label,
			hover,
		});
		self.shapes.len() - 1
	}

	// Generated by chatgpt
	pub fn make_chart(&mut self, data: Vec<i32>, title: &str, x_axis: &str, y_axis: &str) {
		if data.is_empty() {
			return;
		}

		// Define chart margins and dimensions.
		let left_margin = 50;
		let right_margin = 20;
		let top_margin = 50;
		let bottom_margin = 50;
		let segment_width = 3;
		let n = data.len();
		let plot_width = (n - 1) as i32 * segment_width;
		let plot_height = 100; // fixed plot height

		// Determine scaling based on the maximum value.
		let max_value = data.iter().cloned().max().unwrap_or(0).max(1); // avoid division by zero
		let scale = plot_height as f32 / max_value as f32;

		// Total dimensions.
		let total_width = left_margin + plot_width + right_margin;
		//let total_height = top_margin + plot_height + bottom_margin;

		// Add axes (in black).
		self.shapes.push(Shape::Line {
			x1: left_margin,
			y1: top_margin + plot_height,
			x2: left_margin + plot_width,
			y2: top_margin + plot_height,
			colour: "black".to_string(),
			stroke_width: 1,
		});
		self.shapes.push(Shape::Line {
			x1: left_margin,
			y1: top_margin,
			x2: left_margin,
			y2: top_margin + plot_height,
			colour: "black".to_string(),
			stroke_width: 1,
		});

		// Compute data point coordinates.
		let mut points = Vec::new();
		for (i, &val) in data.iter().enumerate() {
			let x = left_margin + (i as i32 * segment_width);
			// In SVG, y increases downward so we subtract.
			let y = top_margin + plot_height - ((val as f32 * scale).round() as i32);
			points.push((x, y));
		}

		// Draw blue line segments connecting consecutive data points.
		for pair in points.windows(2) {
			if let [p1, p2] = pair {
				self.shapes.push(Shape::Line {
					x1: p1.0,
					y1: p1.1,
					x2: p2.0,
					y2: p2.1,
					colour: "blue".to_string(),
					stroke_width: 2,
				});
			}
		}

		// Add title text (centered, black).
		let title_x = total_width / 2;
		let title_y = top_margin / 2;
		self.shapes.push(Shape::Text {
			x: title_x,
			y: title_y,
			text: title.to_string(),
			colour: "black".to_string(),
			font_size: 16,
			anchor: Some("middle".to_string()),
			rotate: None,
		});

		// Add x-axis label (centered, black).
		let x_label_x = left_margin + plot_width / 2;
		let x_label_y = top_margin + plot_height + bottom_margin / 2 + 10;
		self.shapes.push(Shape::Text {
			x: x_label_x,
			y: x_label_y,
			text: x_axis.to_string(),
			colour: "black".to_string(),
			font_size: 12,
			anchor: Some("middle".to_string()),
			rotate: None,
		});

		// Add y-axis label (rotated -90 degrees).
		let y_label_x = left_margin / 2;
		let y_label_y = top_margin + plot_height / 2;
		self.shapes.push(Shape::Text {
			x: y_label_x,
			y: y_label_y,
			text: y_axis.to_string(),
			colour: "black".to_string(),
			font_size: 12,
			anchor: Some("middle".to_string()),
			rotate: Some((-90.0, y_label_x, y_label_y)),
		});
	}

	pub fn save<P>(&self, filename: P) -> io::Result<()>
	where
		P: Into<PathBuf>,
	{
		// Determine overall canvas dimensions from all shapes.
		let mut max_w = 0;
		let mut max_h = 0;
		for shape in &self.shapes {
			match shape {
				Shape::Rect(r) => {
					let right = r.x + r.w;
					let bottom = r.y + r.h;
					if right > max_w {
						max_w = right;
					}
					if bottom > max_h {
						max_h = bottom;
					}
				},
				Shape::Line { x1, y1, x2, y2, .. } => {
					max_w = max_w.max(*x1).max(*x2);
					max_h = max_h.max(*y1).max(*y2);
				},
				Shape::Text { x, y, .. } => {
					max_w = max_w.max(*x);
					max_h = max_h.max(*y);
				},
				_ => {},
			}
		}
		// Add a small margin.
		let (svg_w, svg_h) = (max_w + 20, max_h + 20);

		let mut svg_data = format!(
			r#"<svg xmlns="http://www.w3.org/2000/svg" width="{}" height="{}">"#,
			svg_w, svg_h
		);

		{
			let colour_str = rgb_to_string((255, 255, 255));
			svg_data.push_str(&format!(
				r#"<rect x="{}" y="{}" width="{}" height="{}" fill="{}">"#,
				0, 0, svg_w, svg_h, colour_str
			));
			svg_data.push_str("</rect>");
		}

		for shape in &self.shapes {
			match shape {
				Shape::Rect(r) => {
					let colour_str = rgba_to_string(r.colour);
					svg_data.push_str(&format!(
						r#"<rect x="{}" y="{}" width="{}" height="{}" fill="{}">"#,
						r.x, r.y, r.w, r.h, colour_str
					));
					if let Some(txt) = &r.hover {
						svg_data.push_str(&format!(r#"<title>{}</title>"#, txt));
					}
					svg_data.push_str("</rect>");

					if let Some(txt) = &r.label {
						let cx = r.x + r.w / 2;
						let cy = r.y + r.h / 2;
						svg_data.push_str(&format!(
							r#"<text x="{}" y="{}" text-anchor="middle" alignment-baseline="middle" fill="black">{}</text>"#,
							cx, cy, txt
						));
					}
				},
				Shape::Wire(l) => {
					let wire_colour = match l.attachment_a {
						0 | 2 => "red",
						1 | 3 => "green",
						_ => unreachable!(),
					};
					let (x1, y1) = match self.shapes.get(l.shape_a) {
						Some(Shape::Rect(ra)) => rect_attachment(ra, l.attachment_a),
						Some(Shape::Circle { cx, cy, r, .. }) => {
							circ_attachment(*cx, *cy, *r, l.attachment_a)
						},
						_ => panic!("Wire {:?} references invalid shape!", shape),
					};

					let (x2, y2) = match self.shapes.get(l.shape_b) {
						Some(Shape::Rect(rb)) => rect_attachment(rb, l.attachment_b),
						Some(Shape::Circle { cx, cy, r, .. }) => {
							circ_attachment(*cx, *cy, *r, l.attachment_b)
						},
						_ => panic!("Wire {:?} references invalid shape!", shape),
					};

					svg_data.push_str(&format!(
						r#"<line x1="{}" y1="{}" x2="{}" y2="{}" stroke="{}" stroke-width="1" />"#,
						x1, y1, x2, y2, wire_colour
					));
				},
				Shape::Line {
					x1,
					y1,
					x2,
					y2,
					colour,
					stroke_width,
				} => {
					svg_data.push_str(&format!(
						r#"<line x1="{}" y1="{}" x2="{}" y2="{}" stroke="{}" stroke-width="{}" />"#,
						x1, y1, x2, y2, colour, stroke_width
					));
				},
				Shape::Text {
					x,
					y,
					text,
					colour,
					font_size,
					anchor,
					rotate,
				} => {
					if let Some((angle, rx, ry)) = rotate {
						svg_data.push_str(&format!(
                            r#"<text x="{}" y="{}" fill="{}" font-size="{}" text-anchor="{}" transform="rotate({} {} {})">{}</text>"#,
                            x,
                            y,
                            colour,
                            font_size,
                            anchor.clone().unwrap_or_else(|| "start".to_string()),
                            angle,
                            rx,
                            ry,
                            text
                        ));
					} else {
						svg_data.push_str(&format!(
							r#"<text x="{}" y="{}" fill="{}" font-size="{}" text-anchor="{}">{}</text>"#,
							x,
							y,
							colour,
							font_size,
							anchor.clone().unwrap_or_else(|| "start".to_string()),
							text
						));
					}
				},
				Shape::Circle {
					cx,
					cy,
					r,
					colour,
					label,
					hover,
				} => {
					let colour_str = rgb_to_string(*colour);
					svg_data.push_str(&format!(
						r#"<circle cx="{}" cy="{}" r="{}" fill="{}">"#,
						cx, cy, r, colour_str
					));
					if let Some(txt) = &hover {
						svg_data.push_str(&format!(r#"<title>{}</title>"#, txt));
					}
					svg_data.push_str("</circle>");

					if let Some(txt) = &label {
						svg_data.push_str(&format!(
							r#"<text x="{}" y="{}" text-anchor="middle" alignment-baseline="middle" fill="black">{}</text>"#,
							cx, cy, txt
						));
					}
				},
			}
		}

		svg_data.push_str("</svg>");

		let mut file = File::create(filename.into())?;
		file.write_all(svg_data.as_bytes())?;
		Ok(())
	}
}

fn rect_attachment(r: &RectData, attachment_index: u32) -> (i32, i32) {
	let wx1 = r.x + (r.w as f32 * 0.75) as i32;
	let wx2 = r.x + (r.w as f32 * 0.25) as i32;
	let wy1 = r.y + (r.h as f32 * 0.75) as i32;
	let wy2 = r.y + (r.h as f32 * 0.25) as i32;

	match attachment_index {
		3 => (wx1, wy1),
		2 => (wx1, wy2),
		1 => (wx2, wy1),
		0 => (wx2, wy2),
		_ => unreachable!(),
	}
}

fn circ_attachment(cx: i32, cy: i32, r: i32, attachment_index: u32) -> (i32, i32) {
	let wx1 = cx + (r as f32 * 0.75) as i32;
	let wx2 = cx + (r as f32 * 0.25) as i32;
	let wy1 = cy + (r as f32 * 0.75) as i32;
	let wy2 = cy + (r as f32 * 0.25) as i32;

	match attachment_index {
		3 => (wx1, wy1),
		2 => (wx1, wy2),
		1 => (wx2, wy1),
		0 => (wx2, wy2),
		_ => unreachable!(),
	}
}

fn rgb_to_string(c: (u8, u8, u8)) -> String {
	format!("rgb({},{},{})", c.0, c.1, c.2)
}

fn rgba_to_string(c: (u8, u8, u8, f32)) -> String {
	format!("rgba({},{},{},{})", c.0, c.1, c.2, c.3)
}
